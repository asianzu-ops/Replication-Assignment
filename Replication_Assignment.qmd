---
title: "Replication-Assignment"
format: html
editor: visual
---

#Data Analysis Replication Assignment

#Step 1:Original Paper and replication Goal

```{r}

#Goal of the Paper:
  
#The study conducted by Sandel et al.(2021) aimed to investigate how social network structure influences the transmission of a respiratory disease outbreak among wild chimpanzees. The study sought to determine whether individual social connections predicted exposure to infection.

#Data Set Used:
#The study was conducted on a chimpanzee group inKibale National Park, Uganda.

#Researchers collected behavioral and epidemiological data from 40 adult and adolescent male chimpanzees during a respiratory disease outbreak.

#Symptoms such as coughing and rhinorrhea were recorded to identify infected individuals.

#Analyses:
  
#Social Network Analysis: Constructed networks based on chimpanzee associations to identify individual connectivity.

#Epidemiological Modeling: Assessed the relationship between an individualâ€™s social connections and the likelihood of infection.

#Statistical Tests: Used regression models to test whether more socially connected individuals had higher chances of exposure to infection.


#Analyses to be conducted.

#Descriptive Analysis to Replicate:
#Social Network Analysis:compute basic network metrics such as the number of connections.

#Regression Analysis: model the relationship between social connectivity and infection likelihood using logistic regression.


```

#Step 2: Loading the data files

```{r}
#This section of code includes files and relevant libraries that will be used to conduct the analysis.

setwd("C:\\Users\\Asianzu Blessing\\Downloads")


s_raw <- readRDS("C:/Users/Asianzu Blessing/Downloads/sicknessRawData.rds")
p_raw <- readRDS("C:/Users/Asianzu Blessing/Downloads/allRawProx5Data.rds")
i_raw <- readRDS("C:/Users/Asianzu Blessing/Downloads/totalNumberOfScansPerIndividual.rds")

head(s_raw)
head(p_raw)
head(i_raw)


colnames(s_raw)
colnames(p_raw)
colnames(i_raw)


#Fig share Data 

d <- ("C:/Users/Asianzu Blessing/Downloads/individual chimpanzee data.csv")
p <- ("C:/Users/Asianzu Blessing/Downloads/5m network adjacency matrix.csv")

d <- read.csv(d, header = TRUE)
p <- read.csv(p, header = TRUE)


head(d)
head(p)

colnames(d)
colnames(p)



```

#Step 3A:Social network Plot

```{r}

#This script uses igraph and dplyr packages to visualize the proximity network based on the symptomatic status of the study idividuals(nodes). The igraph package is used to create and plot the network graph, where the edges represent proximity data, and the vertices are colored based on whether a chimpanzee is symptomatic (red) or not (green). The dplyr package  is used in the data manipulation tasks. The network visualization is generated by using igraph's functions to define a layout and adjust visual settings like vertex size, label size, and edge width, providing a clear representation of the proximity network and its relation to clinical status.

library(tidyverse)
library(igraph)


proximity_data <- p[, -1]

edges <- data.frame(from = character(0), to = character(0), weight = numeric(0))

for (i in 1:(ncol(proximity_data) - 1)) {
  for (j in (i + 1):ncol(proximity_data)) {
    if (proximity_data[i, j] > 0) {  
      edges <- rbind(edges, data.frame(from = colnames(proximity_data)[i], 
                                       to = colnames(proximity_data)[j], 
                                       weight = proximity_data[i, j]))
    }
  }
}


g <- graph_from_data_frame(edges, directed = FALSE)

print(head(d)) 

symptomatic <- d$symptomatic  

vertex_names <- V(g)$name

print(head(vertex_names))

symptomatic_ordered <- symptomatic[match(vertex_names, d$identity)]

V(g)$color <- ifelse(symptomatic_ordered == 1, "red", "green")

layout_matrix <- layout_with_fr(g)

plot(g, 
     layout = layout_matrix,  
     vertex.size = 15, 
     vertex.label.cex = 0.7, 
     edge.width = E(g)$weight * 10,  
     vertex.color = V(g)$color,     
     main = "Proximity Network with Symptomatic Status")




```

#Step 3B:Failed attempt of adding the shade effect by neighborhood

```{r}

#For this section I used the igraph and ggraph packages to visualize the proximity network of chimpanzees, the graph_from_data_frame() function from igraph to create the graph from an edge list earlier on calculated. The layout_with_fr() function to position the nodes using the Fruchterman-Reingold layout. The chull() function to compute convex hulls around neighborhoods, and ggraph() for plotting the network with convex hulls overlay. Nodes are colored based on neighborhoods (Central, East, West), and the edge connections are visualized to highlight proximity relationships within the network but it still didnt yield. 


#Creating the graph
g <- graph_from_data_frame(edges, directed = FALSE)

#matrix for positioning nodes
layout_matrix <- layout_with_fr(g)

#layout matrix to a tibble with proper column names (x and y)
fixed_layout <- as_tibble(layout_matrix, .name_repair = "unique")
colnames(fixed_layout) <- c("x", "y")


#assigning a random neighborhood label to each vertex for demonstration
V(g)$neighborhood <- sample(c("Central", "East", "West"), vcount(g), replace = TRUE)

#Converting the layout to a tibble and adding neighborhood
fixed_layout$neighborhood <- V(g)$neighborhood

#Computing the polygon for each neighborhood
neighborhoods <- unique(fixed_layout$neighborhood)
polygon_data <- list()

#Loop through each neighborhood
for (neighborhood in neighborhoods) {
 neighborhood_data <- fixed_layout %>% filter(neighborhood == !!neighborhood)
  hull_indices <- chull(neighborhood_data$x, neighborhood_data$y)
  hull_data <- neighborhood_data[hull_indices, ]
  hull_data$neighborhood <- neighborhood
  polygon_data[[neighborhood]] <- hull_data
}

#Combining all hull data into one data frame
polygon_data <- bind_rows(polygon_data)

#Plotting network with convex hull polygons
ggraph(g, layout = 'manual', x = fixed_layout$x, y = fixed_layout$y) +  
 
  geom_polygon(data = polygon_data, 
               aes(x = x, y = y, group = neighborhood, fill = neighborhood), 
               alpha = 0.3, color = "black") +  
 
  geom_edge_link(aes(alpha = 0.5), color = "grey") +
  
  geom_node_point(aes(color = neighborhood), size = 5) +
  theme_void() +
  scale_fill_manual(values = c("Central" = "red", "East" = "blue", "West" = "green")) +
  scale_color_manual(values = c("Central" = "darkred", "East" = "darkblue", "West" = "darkgreen")) +
  theme(legend.position = "top", plot.title = element_text(hjust = 0.5)) +
  ggtitle("Proximity Network with Convex Hulls Overlay")

#Not quite the output as the original paper's image 


```

#Step 4:Calculating and visualising mean weighted shortest path

```{r}

#Here I analyze the proximity of symptomatic chimpanzees in the network by calculating the mean weighted shortest path from each node to the nearest symptomatic individual. The igraph package used to create the graph with graph_from_data_frame(). V(g)$symptomatic assigns the symptomatic status to each node, and the distances() function computes the shortest path between nodes. A permutation test is performed by shuffling the symptomatic status 1000 times to create a null distribution, and the observed mean path length is compared to this null distribution. A p-value calculated to assess the significance of the observed path length. The null distribution is visualized using a histogram with the observed mean path length.


# Create the graph from edges
g <- graph_from_data_frame(edges, directed = FALSE)

# Assigning symptomatic status to nodes
V(g)$symptomatic <- d$symptomatic  

#symptomatic nodes
symptomatic_nodes <- V(g)[V(g)$symptomatic == 1]

#mean weighted shortest path to the nearest symptomatic individual
mean_weighted_path_length_symptomatic <- mean(sapply(V(g), function(v) {
  if (length(symptomatic_nodes) > 0) { 
    # Calculate the distances to symptomatic nodes with weights
    distances_to_symptomatic <- distances(g, v, symptomatic_nodes, weights = E(g)$weight)
    
  
    if (all(is.infinite(distances_to_symptomatic))) {
      return(NA)  
    } else {
   
      return(min(distances_to_symptomatic, na.rm = TRUE)) 
    }
  } else {
    return(NA)
  }
}), na.rm = TRUE)

cat("Observed mean weighted path length to symptomatic:", mean_weighted_path_length_symptomatic, "\n")

# Null distribution by randomizing symptomatic nodes
num_simulations <- 1000
null_distribution <- numeric(num_simulations)

for (i in 1:num_simulations) {
  
  # Randomly shuffle the symptomatic labels
  V(g)$symptomatic <- sample(d$symptomatic)  
  shuffled_symptomatic_nodes <- V(g)[V(g)$symptomatic == 1]
  
  #Computing mean weighted path length
  mean_weighted_path_length_shuffled <- mean(sapply(V(g), function(v) {
    if (length(shuffled_symptomatic_nodes) > 0) {
      
      distances_to_shuffled <- distances(g, v, shuffled_symptomatic_nodes, weights = E(g)$weight)
      
      
      if (all(is.infinite(distances_to_shuffled))) {
        return(NA)
      } else {
       
        return(min(distances_to_shuffled, na.rm = TRUE))
      }
    } else {
      return(NA)
    }
  }), na.rm = TRUE)
  
  null_distribution[i] <- mean_weighted_path_length_shuffled
}

# Calculating p-value
p_value <- mean(null_distribution <= mean_weighted_path_length_symptomatic)
cat("P-value:", p_value, "\n")

# Visualize the null distribution and observed mean weighted path length
hist(null_distribution, 
     main = "Null Distribution of Mean Weighted Path Lengths", 
     xlab = "Mean Weighted Path Length", 
     col = "lightblue", 
     breaks = 30)

# Add a line for the observed value
abline(v = mean_weighted_path_length_symptomatic, col = "red", lwd = 2)

# Add a legend for the observed value
legend("topright", legend = paste("Observed:", round(mean_weighted_path_length_symptomatic, 3)),
       col = "red", lwd = 2)




#The observed mean path length to the nearest symptomatic individual in my analysis was 0.000888, with a p-value of 0.05 from 1,000 randomizations. Compared to the original study which reported a mean weighted path length of 15.04 and a p-value of 0.014, my result shows a significant difference in the mean values. However,both analyses indicate a significant relationship between the network topology and the proximity of symptomatic individuals, with mine being less significant than the original study. 

#This difference in the values I got and that of the original analysis could probably be due to edge weighting or the method used to calculate path lengths (mean vs. weighted).


```

#Step 5:Logistic regression with the predictor variables

```{r}

#This code uses logistic regression to examine the relationship between node strength centrality and the probability of respiratory symptoms (symptomatic status). The glm() function from R fits the logistic regression model, with summary() providing model coefficients and p-values. The model predicts the probability of symptoms based on node strength centrality. ggplot2, used to visualize the data and the fitted logistic curve. The geom_point() function creates a scatter plot of the data, while geom_smooth() adds the fitted logistic curve. The plot highlights the relationship between node strength centrality and the probability of infection. Finally, the script prints model coefficients and p-values to assess the statistical significance of the predictors.


library(ggplot2)

#Defining the model 
model <- glm(symptomatic ~ strength.centrality + age + dominance.score , data = d, family = binomial)

summary(model)



#data for logistic regression
network_data <- data.frame(node_strength = d$strength.centrality, symptomatic = d$symptomatic)

# Fitting the logistic regression model
log_reg_model <- glm(symptomatic ~ node_strength, + age + dominance.score, data = network_data, family = binomial)

summary(log_reg_model)


network_data$predicted_prob <- predict(log_reg_model, type = "response")

# Plotting fitted regression curve
ggplot(network_data, aes(x = node_strength, y = symptomatic)) +
  geom_point(alpha = 0.5) +  # Scatter plot of the actual data
  geom_smooth(method = "glm", method.args = list(family = "binomial"), 
              se = FALSE, color = "red") +  # Fitted logistic curve
  labs(x = "Node Strength Centrality", 
       y = "Probability of Respiratory Symtpoms", 
       title = "Strength Centrality Predicts Clinical Signs of Infection") +
  theme_minimal()


cat("Model Coefficients:\n")
print(coef(log_reg_model))
cat("\nP-values:\n")
print(summary(log_reg_model)$coefficients[, 4])



#The logistic regression model shows that node strength centrality significantly predicts the likelihood of exhibiting symptoms. The intercept is not significant, but the coefficient for node strength (7.197) is statistically significant (p = 0.0277), indicating that higher node strength increases the probability of symptomatic infection, suggesting that more centrally connected individuals in the social network are more likely to show clinical signs. However, age (Î² = -0.031, P = 0.5147) and dominance score (Î² = -1.14, P = 0.5668) did not significantly influence the probability of exhibiting clinical signs.The model's residual deviance was 36.663, with an AIC of 44.663 suggests a reasonable fit. 

#In the original study,permutation-based regression model found that strength centrality is significantly linked to the likelihood of exhibiting clinical signs, with higher centrality increasing the probability (Î²_strength = 9.47, P = 0.006). Rank and age did not directly affect the likelihood of showing clinical signs (P > 0.05), but both were positively correlated with centrality. 


```

#Step 6:Permutation-based testing for the logistic model

```{r}

#This chunk uses logistic regression to examine whether social network metrics (strength centrality, eigenvector centrality, flow betweenness), age, and dominance score predict symptomatic status in a suspected disease outbreak. The glm() function from the MASS package fits the logistic model. To ensure robustness, the permute_regression() function performs a permutation test, randomly shuffling the response variable (symptomatic) 30,000 times and refitting the model. This generates a null distribution of coefficients, allowing empirical p-values to assess significance. The apply() function is used to calculate p-values.


#Load library
library(MASS) 

# Defining the logistic regression model
log_reg_model <- glm(symptomatic ~ strength.centrality + eigenvector.centrality + 
                      flow.betweenness + age + dominance.score,
                     data = d, family = binomial)


permute_regression <- function(data, response_var, predictor_vars, n_perm = 1000) {
  observed_coefficients <- coef(glm(as.formula(paste(response_var, "~", paste(predictor_vars, collapse = "+"))),
                                    data = data, family = binomial))
  
  permuted_coefficients <- matrix(NA, nrow = n_perm, ncol = length(observed_coefficients))
  
  for (i in 1:n_perm) {
   
    permuted_data <- data
    permuted_data[[response_var]] <- sample(permuted_data[[response_var]])
    
   
    perm_model <- glm(as.formula(paste(response_var, "~", paste(predictor_vars, collapse = "+"))),
                      data = permuted_data, family = binomial)
    
   
    
    permuted_coefficients[i, ] <- coef(perm_model)
  }
  
  return(list(observed = observed_coefficients, permuted = permuted_coefficients))
}

# Run the permutation-based regression
response_variable <- "symptomatic"
predictors <- c("strength.centrality", "eigenvector.centrality", "flow.betweenness", 
                "age", "dominance.score")  



perm <- permute_regression(d, response_variable, predictors, n_perm = 30000)


#Calculate p-values based on the observed coefficients and permuted coefficients
p_values <- apply(perm$permuted, 2, function(coef_column) {
  mean(abs(coef_column) >= abs(perm$observed))
})

#coefficients and p-values
cat("Observed Coefficients:\n")
print(perm$observed)

cat("\nP-values based on permutation:\n")
print(p_values)


```

#Step7:Checking for multicollinearity

```{r}

#running a generalised linear model to check for multicollinearity for all the predictor variables for the analyses of the original and the replication task

library(car)

log_reg_model <- glm(symptomatic ~ strength.centrality + eigenvector.centrality + 
                      flow.betweenness + age + dominance.score, 
                     data = d, family = binomial)

# Calculate VIF
vif_result <- vif(log_reg_model)

print(vif_result)



#The specific VIF for the predictor variables of the original paper were not reported but they were all less than 2, which aligns with my varianca inflation factors, showing almost no collinearity.  
```

#Step 8:Discussion

```{r}

#Overall, the findings from my analysis and the original study share are in highlighting social network position, particularly strength centrality, in influencing the likelihood of chimpanzees exhibiting respiratory infection signs. Both analyses suggest that chimpanzee central positions in the social network were more likely to show clinical signs of infection, while age and dominance rank had minimal direct effects on the probability of exhibiting these clinical signs. 

#However, a key difference between my analysis and the original study lies in the statistical significance of the findings. In the original study, strength centrality showed a significant correlation with infection likelihood, while rank and age had negligible effects. In my  analysis, while I have a similar trend, the relationships between network centrality and infection likelihood did not achieve statistical significance. This differece could be attributed to the statistical models that I used to run the analysis. 


#Challenges: I failed to create a group shade for the networks based on neighborhood as it appears in the original study's network plot. Secondly, I tried using the same logistic regression package (pbr.logistic used in the original study) but I failed to get it loaded even after installing pbr in R so that could have altered the analysis, I am not sure. 


```

#Step 9:Original Study images

```{r}

#Images here consist of visualisation from the original paper


#| out-width: ###px
knitr::include_graphics("Fitted logistic regession HTML.webp")

#| out-width: ###px
knitr::include_graphics("Network plot_Fig2_HTML.webp")


```
